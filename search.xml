<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[旅行商问题]]></title>
    <url>%2Fposts%2Fdcbe0c49%2F</url>
    <content type="text"><![CDATA[问题描述 一位旅行商要去n座城市, 选择不同的城市顺序, 有不同的路线, 求找最短路程的路线 时间复杂度O(n!)似乎无优化解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>有趣</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python元类]]></title>
    <url>%2Fposts%2Fd04e1a92%2F</url>
    <content type="text"><![CDATA[我们创建的对象一般时从object继承来的, 但是如果我们: 12type(object) type 元类是什么？元类实际上就是用来创建类的东西事实上type就是一个元类, 是用来创建所有的类的元类 元类如果我们要创建自己定义的元类的话，也要从type中继承 原理123456789# 创建一个元类class OneSunMetaclass(type): pass# 元类给我们的类使用class Foo(object， metaclass = OneMetaclass): pass# 继承class Bar(Foo): pass 对于父类Foo，Python会寻找__metaclass__, 如果找到了, Python就会用它来创建类Foo, 如果没有找到, 就会用内建的type来创建这个类 对于子类Bar, python会先在子类中寻找__metaclass__, 如果找到了, Python就会用它来创建类Bar, 如果没有找到, 就再从父类中寻找__metaclass__, 直到type创建元类元类的主要目的就是为了当创建类时能够自动地改变类。创建类我们需要定义__new__，__new__ 是在__init__之前被调用的特殊方法，是用来创建对象并返回的方法 1234class OneMetaclass(type): def __new__(cls, name, bases, attrs): ... return type.__new__(cls, name, bases, attrs) __new__接受四个参数cls — 当前准备创建的类的对象name — 类的名字, 字符串bases — 类继承的父类, 列表attrs — 类的属性, 列表]]></content>
      <categories>
        <category>Python</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python装饰器]]></title>
    <url>%2Fposts%2Ff2b4268f%2F</url>
    <content type="text"><![CDATA[python中的语法糖, 装饰器, 需要先搞清楚闭包和函数参数解包 装饰器装饰器要装饰一个对象, 可以是函数, 可以是类, 装饰器本身可以是函数也可以是类 装饰 能够接受一个对象 要有对对象的修改或利用对象的能力 对象的基本功能不能变(装饰不应该改变我们写出的直观的功能) 装饰器可能还需要我们能够进行一定的控制, 它可能会需要参数 如果我们愿意, 不应该只能装饰一次 一个例子一个函数装饰函数的例子 1234567891011121314151617181920import timedef de(func, *args, **kwargs): def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) print('%.3f s' % (time.time() - start)) return result return wrapper@dedef f(): time.sleep(3.123) print("Hi...")# 上述函数定义等价于f = de(f)f()Hi...3.124 s 能够接受一个对象函数当然可以接受一个函数作为参数 要有对对象的修改或利用对象的能力我们当然可以在装饰器内做些事情, 比如计算运行时间 这还是可以应在任意函数的装饰器, 我们还可以为特定的函数编写装饰器, 比如flask将视图函数与路由连接起来 对象的基本功能不能变正如我们看到的, 将所有的参数获取并传给原来的函数 我们返回一个函数 什么也不做的装饰器12345678def de(func, *args, **kwargs): def wrapper(*args, **kwargs): return func(*args, **kwargs) return wrapper # 甚至是这样def de(func): return func 我们需要参数123456789101112131415161718192021# 需要嵌套更多def de2(s): def de(func): def wrapper(*args, **kwargs): start = time.time() time.sleep(s) result = func(*args, **kwargs) print('%.3f s' % (time.time() - start)) return result return wrapper return de@de2(2)def f2(): print("Hi.....")# 相当于 f2 = de2(s)(f2)f2()Hi.....2.001 s f2 = de2(s)(f2) de2(s)返回了一个函数de, 即de2(s)=de, 即我们没有参数时的装饰器de(f2), 返回了我们的函数 应该记住的最后返回的是最内层的wrapper函数, wrapper外部的函数都已执行所以我们可以看作装饰有两部分, 一部分wrapper函数外部代码, 定义函数时即进行装饰,另一部分是wrapper内部代码, 调用时进行装饰 不仅要原函数的返回值12345678910def de2(s): def de(func): def wrapper(*args, **kwargs): start = time.time() time.sleep(s) result = func(*args, **kwargs) print('%.3f s' % (time.time() - start)) return result return wrapper, time.time() - start return de 多个装饰器离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰我们最好不要写……会晕的 类装饰器类装饰器依赖的是类的__call__方法 12345678910111213141516171819class De(): def __init__(self, func): self.s = "Hi!" self.func = func def __call__(self, *args, **kwargs): print(self.s) return self.func(*args, **kwargs)@Dedef foo(s): print(s)# 相当于foo = De(foo).__call__foo("Hi...")Hi!Hi... 使用场景通用装饰器就像例子中的装饰器, 用在那个函数上都可以 日志 运行时间 其他 将函数余其他东西关联, url和view django注册应用 注册任务 原函数调用前检查 权限验证 类型检查 输出格式化 原函数调用时检查 异常捕捉 函数调用后的一些处理 注意原函数的属性会变例, 函数也是个对象, 它的属性__name__为函数名, 但是装饰器工作后会改变它的属性, 按照我们的等价写法来理解, 这很正常.解决引起我们函数名改变的原因就是wrapper的调用, 所以我们可以手动修改wrapper.__name__=func.__name__更好的方法是使用functools库的wraps装饰器 123@functools.wraps(func):def wrapper(*arg, **kwargs): ... 这样使用装饰器不会有任何副作用 模板有时我们直接记住一些模板就好了, 甚至我们都不会取写装饰器, 最少应该在自己使用时了解它工作的过程 函数装饰函数123456789def de(cls): ... def wrapper(*arg, **kwargs): ... result = cls(*arg, **kwargs) ... return result[, ...] ... return wrapper 函数装饰类123456789def de(cls): ... def wrapper(*arg, **kwargs): ... instance = cls(*arg, **kwargs) ... return instance[, ...] ... return wrapper 类装饰函数123456789101112class De(): def __init__(self, func): self.func = func ... ... def __call__(self, *args, **kwargs): ... result = self.func(*args, **kwargs) ... return result[, ...] 类装饰类123456789101112class De(): def __init__(self, cls): self.cls = cls ... ... def __call__(self, *args, **kwargs): ... instance = self.cls(*args, **kwargs) ... return instance[, ...]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python闭包]]></title>
    <url>%2Fposts%2Fc951a1d4%2F</url>
    <content type="text"><![CDATA[闭包, 仅讨论传统的函数意义上的闭包 闭包返回一个函数 有时我们会遇到这样一个情况, 函数的返回值是个函数 还要使用其外侧函数的局部变量 返回的函数还要使用其外侧函数的变量, 一般来说, 如果一个函数结束，函数的内部所有东西都会释放掉，这时有个问题, 如果是这样工作的, 调用返回的函数时怎么办? 事实上, python确实是这样工作的, 只是对这种情况做特殊处理(还可能是可变变量允许它调用), 这种情况我们叫做闭包. 如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。 这也是装饰器的基础 坑拿到的变量只有一份如果我们写了一个函数, 那每次调用这个函数时, 函数内的局部变量都会在每次调用时重置.而闭包不是这样, 函数能调用多次, 外侧函数结束时交给它的局部变量只有一份, 每次调用这个变量不会充值 123456789101112131415def f1(): t = 0 start = time.time() def spend(): nonlocal t t = t + time.time()-start print(t) return spendt = f1()t()time.sleep(2)t()time.sleep(2)t() 调用时才会执行如果返回了多个待调用的函数, 而这些函数中使用了上述的变量, 那就会出现问题, 原因就是使用的外侧函数的变量只有一份 123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 解决办法: 不写这样的东西 让这样的函数在内部被调用, 返回一个新的函数, 这个新的函数返回真正工作的函数的结果]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>闭包</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2Fposts%2F53b5426a%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git忽略文件.gitignore]]></title>
    <url>%2Fposts%2F181a9d16%2F</url>
    <content type="text"><![CDATA[.gitignore 文件(夹)以glob模式匹配Github各种.gitignore文件 github/gitignore 常见问题在.gitignore中添加了某文件, 却仍然追踪 如果一个文件一开始没有添加到.gitignore里面，中途添加进去。git 将不会忽略这个文件。 可以在本地缓存删除这个文件, 然后在提交 1git rm -r --cached &lt;FileName&gt;]]></content>
      <categories>
        <category>Code</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件权限设置]]></title>
    <url>%2Fposts%2Fceb060d6%2F</url>
    <content type="text"><![CDATA[Linux 文件基本属性 1-9号代表各种用户的权限 三个一组, 二进制表示, 若为1则可读/写/执行, 设置时可以每组之和的八进制表示则 只读4, 只写2, 只执行1, 可读可写6, 全权限7 仅属主拥有全权限, 其他用户尽可读, 744 Python递归创建目录12import osos.makedirs(name, mode=0o777, exist_ok=False) 若exist_ok设为False, 则目录存在时返回FileExistsError]]></content>
      <categories>
        <category>Code</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>IO</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PYthon打包时非python源码文件的处理]]></title>
    <url>%2Fposts%2Fbb04cb3e%2F</url>
    <content type="text"><![CDATA[目录结构项目结构12345678910111213project/ |---package |---__init__.py |---main.py config.json |---data |---doc.txt ---ui.css |---README.md |---MANIFEST.in |---favicon.ico |---LICENSE ---setup.py 非源码文件位置三种: 包内, 如config.json 项目非包子文件下,如doc.txt 项目文件夹下, 如README.md, favicon.ico, LICENSE 将这些文件包含在内的几种设置它门都被传递给setup()的参数中, 和一个文件MANIFEST.in中设置 一个文件MANIFEST.in文件十分重要, 后面参数的指定都因为各种原因, 需要将文件添加到这里 include_package_data = (bool) 决定是否打包数据, 也就是说影响的是包内的, 想config.json当然如果愿意, 也可以在data目录下放一个__init__.py文件, 是的其成为一个包, 尽管其中没 有任python源文件 需要将你需要的文件添加到MANIFEST.in文件中, 这是被要求的 package_data = {(str), [(str), (str)]} 像第一类文件, 除了上面的方法, 还可以使用这个参数, 这是一个更加细化的控制方式 使用了上面的参数, 则最好不要再使用这个参数 由于过去有的版本的要求, 最好将这里指定的文件也添加到MANIFEST.in文件中去 文件指定 1234567891011from setuptools import setup, find_packagessetup( ... package_data = &#123; # 键为包, 值为glob表达式 # ""空字符串指定所有包 # 分隔符, 必须用/ '': ['*.txt', '*.rst'], 'package': ['sh/*.sh'], &#125;) 注意, 修改了这个参数, 最好删除所有原来打包记录文件, 其中可能会有部分文件记录了之前指定的文件, 但在你修改了之后它们却没有正确修改 可以运行python setup.py clean --all 访问方法 官方给出的方法并不清楚 12345# 可能我们是这样访问的foo_config = open(os.path.join(os.path.dirname(__file__),'foo.conf').read()# 官方建议你from pkg_resources import resource_string # 还有resource_streamfoo_config = resource_string(__name__, 'foo.conf') exclude_package_data = {(str), [(str), (str)]} 这个参数用于指定那些包含在前两个参数中 (打包并安装) 打包但不安装 data_files = [((str), [(str), (str), ]), ] 对于第二, 三类文件似乎只能用这个参数来指定 每个元组指定了文件安装后的相对位置和要安装的文件的位置 访问方法就是使用相对目录sys.prefix 另一个方法仍不清楚 总结 程序源码,依赖文件和数据文件应该分开 需要打包的文件最好都添加到MANIFEST.in文件中 data_files指定的文件肯定不和源代码在一起 包文件由官方访问方法可知可能也会和源代码分开 事实上我在setuptools文档看到, 只要是程序运行时用到的, 都应该包含在包中 Instead, the PyPA recommends that any data files you wish to be accessible at run time be included in the package 而对data_file, setuptools文档似乎没有怎么解释, python文档则有一点说明 It is mostly useful if you need to install files which are used by other programs, which may be unaware of Python packages.]]></content>
      <categories>
        <category>打包与分发</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyPi</tag>
        <tag>setuptools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Melody测试]]></title>
    <url>%2Fposts%2Fbda3d30d%2F</url>
    <content type="text"><![CDATA[特性测试]]></content>
  </entry>
  <entry>
    <title><![CDATA[依据windows绝赞应用挑选整理]]></title>
    <url>%2Fposts%2Face0e55c%2F</url>
    <content type="text"><![CDATA[安全 CCleaner 实用工具集 MyChrome **Office Tool Plus ** **rufus ** 压缩 7-ZIP 终端 Terminus α 开发工具 **Scoop 图片处理游戏相关邮件网络即时通信下载器 EagleGet FDM 笔记生产力]]></content>
      <categories>
        <category>实用效率</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Typora体验]]></title>
    <url>%2Fposts%2F4d942339%2F</url>
    <content type="text"><![CDATA[漂亮 之前都是在用VS Code写，也用过cmd markdown，Typora要漂亮，优雅。 支持 支持markdown的许多扩展语法语法。表格，流程图等等。支持yaml格式，hexo的文章开头都有ymal格式信息。 缺点 不能设置模板。 没有图床，只有Mac才能用。 有的操作很奇怪啊，比如换行会多一行]]></content>
      <categories>
        <category>MarkDown</category>
        <category>实用效率</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[走马川行奉送出师西征]]></title>
    <url>%2Fposts%2F536a2cf0%2F</url>
    <content type="text"><![CDATA[走马川行奉送出师西征** 君不见，走马川行雪海边，平沙莽莽黄入天。轮台九月风夜吼，一川碎石大如斗，随风满地石乱走。匈奴草黄马正肥，金山西见烟尘飞，汉家大将西出师。将军金甲夜不脱，半夜军行戈相拨，风头如刀面如割。马毛带雪汗气蒸，五花连钱旋作冰，幕中草檄砚水凝。虏骑闻之应胆慑，料知短兵不敢接，车师西门伫献捷。** 作者简介——岑参 岑参（715～770），唐代诗人。南阳（今属河南）人。天宝进士，曾随高仙芝到安西、武威，后又往来于北庭、轮台间初为率府兵曹参军,两次从军边塞。官至嘉州（今四川乐山）刺史，因世称岑嘉州。卒于成都。 其诗长于七言歌行。所作题材广泛，善于描绘塞上风光和战争景象；气势豪迈，情辞慷慨，语言变化自如。与高适齐名，并称“高岑”，同为盛唐边塞诗派的代表。 岑参的边塞诗虽然大都写于天宝后期，却不像其他诗人如高适、杜甫等人的同期边塞诗一样注重战争给人民带来的灾难，而是以瑰丽的笔调写边塞的异域风光，写战士的勇武气概与必胜信心。《走马川行奉送出师西征》就是一首代表作。这是基于作者开朗的胸襟、积极进取的精神、好奇的个性和克服困难的勇气，这正是构成”盛唐气象”的主体精神。 杜甫在《溪陂行》中写道：“岑参兄弟皆好奇。”所谓“好奇”，就是爱好新奇事物，诗境造奇。 体裁——歌行体 音节、格律比较自由，形式采用五言、七言、杂言的古体，可参差不齐,可变韵，属于古体诗。“歌行”体诗歌在格律、音韵方面冲破了格律诗的束缚，由于它要“放情长言”，因而句子也多，再要一韵到底。 创作背景 这首诗是岑参任西北庭节度判官时写的。这期间，封常清曾几次出兵作战。岑参对当时征战的艰苦、胜利的欢乐，都有比较深的体会，曾经写了不少诗歌来反映。有一次，封常清出兵去征播仙，在出师时便向封常清献诗两首，其一为本首诗歌，其二为《轮台歌奉送封大夫出师西征》。 关于标题 走马川，即车尔成河，又名左未河，在今新疆境内。川为河道。 行，体裁。 释文及赏析君不见，走马川行雪海边，平沙莽莽黄入天。 您难道不曾看见，辽阔的走马川，紧连雪海边缘，浩瀚的沙漠，黄沙滚滚接云天。 雪海：泛指西北苦寒之地。 首先围绕“风”字落笔，描写出征的自然环境。这次出征将经过走马川、雪海边，穿进戈壁沙漠。“平沙莽莽黄入天”，这是典型的绝域风沙景色，狂风怒卷，黄沙飞扬，遮天蔽日，迷迷蒙蒙，一派混沌的景象。“莽莽”暗写狂风卷着飞沙的迷蒙景象；“黄入天”写大漠风沙的颜色，写风沙直入天际的情景。开头三句无一“风”字，但捕捉住了风“色”，把风的猛烈写得历历在目。这是白天的景象。 轮台九月风夜吼，一川碎石大如斗，随风满地石乱走。 轮台九月整夜里狂风怒号，走马川的碎石块块大如斗，狂风吹得斗大乱石满地走。 对风由暗写转入明写，行军由白日而入黑夜，风“色”是看不见了，便转到写风声。狂风象发疯的野兽，在怒吼，在咆哮，“吼”字形象地显示了风猛风大。接着又通过写石头来写风。斗大的石头，居然被风吹得满地滚动，再著一“乱”字，“乱”，是不规矩，写出了大风刮起后四处回旋的样貌。夸张有节，形象生动。就更表现出风的狂暴。“平沙莽莽”句写天，“石乱走”句写地，三言两语就把环境的险恶生动地勾勒出来了。 匈奴草黄马正肥，金山西见烟尘飞，汉家大将西出师。 这时匈奴草场变黄军马肥，侵入金山西面烟尘滚滚飞，汉家的大将率兵开始征西。 金山：即阿尔泰山。 烟尘飞：指战争已经开始了。 这三句写出征的原因。“烟尘飞”三字，形容报警的烽烟同匈奴铁骑卷起的尘土一起飞扬，既表现了匈奴军旅的气势，也说明了唐军早有戒备。下面，诗由造境转而写人，诗歌的主人公————顶风冒寒前进着的唐军将士出现了。 将军金甲夜不脱，半夜军行戈相拨，风头如刀面如割。 将军身著铠甲夜里也不脱，半夜行军戈矛彼此相碰撞，凛冽寒风吹到脸上如刀割。 环境是夜间，“将军金甲夜不脱”，以夜不脱甲，写将军重任在肩，以身作则。“半夜军行戈相拨”写半夜行军，从“戈相拨”的细节可以想见夜晚一片漆黑，和大军衔枚疾走、军容整肃严明的情景。写边地的严寒，不写千丈之坚冰，而是通过几个细节来描写来表现的。“风头如刀面如割”，呼应前面风的描写；同时也是大漠行军最真切的感受。 马毛带雪汗气蒸，五花连钱旋作冰，幕中草檄砚水凝。 马背上雪花，被汗气熏化蒸发，五花马的斑纹，旋即就结成冰，军帐中，起草檄文砚水也冻凝。 五花连钱：指名贵的马。 “马毛带雪汗气蒸，五花连钱旋作冰。”战马在寒风中奔驰，那蒸腾的汗水，立刻在马毛上凝结成冰。诗人抓住了马身上那凝而又化、化而又凝的汗水进行细致的刻划，以少胜多，充分渲染了天气的严寒，环境的艰苦和临战的紧张气氛。“幕中草檄砚水凝”，军幕中起草檄文时，发现连砚水也冻结了。诗人巧妙地抓住了这个细节，笔墨酣畅地表现出将士们斗风傲雪的战斗豪情。这样的军队有谁能敌呢？这就引出了最后三句，料想敌军闻风丧胆，预祝凯旋而归，行文就象水到渠成一样自然。 虏骑闻之应胆慑，料知短兵不敢接，车师西门伫献捷。 匈奴骑兵，个个闻风心惊胆战，早就料到，他们不敢短兵相接，只在车师西门，等待献俘报捷。 虏骑：敌军。 慑：恐惧 车师：安西都护府所在地，在今新疆吐鲁番。 伫：久立等待。 这三句，预祝战斗的胜利。正是在前文环境描写中所展现的唐军将领身先士卒、不惧艰险的精神的基础上，岑参预示敌军是不敢与这样勇敢的军队交锋的，相信唐军将士必然很快凯旋。一个“伫”，预示了战斗的时间之短，也写出了岑参对唐军必胜的坚定信心。 艺术手法 夸张与贴切的比喻连用：大胆的夸张使得将士不畏艰险的英勇形象更加鲜明生动。 反衬：以对边塞凶险、恶劣的环境描写来反衬将士的豪迈坚强、不畏艰险的气概。 细节描写：注重细节刻画。 萧涤非《唐诗鉴赏辞典》：全篇奇句豪气，风发泉涌，由于诗人有边疆生活的亲身体验，因而此诗能“奇而入理”，“奇而实确”，真实动人。全诗句句用韵，除开头两句外，三句一转韵，这在七言古诗中是不多见的。全诗韵位密集，换韵频数，节奏急促有力，情韵灵活流宕，声调激越豪壮，有如音乐中的进行曲。 敍述征战，却不谈战斗场面，而是从恶劣的自然环境入手，以环境来塑造人物，加之诗句豪放自然，处处放射出无所畏惧之精神力量，读之朗朗入口，气势壮观，节奏有力，激越豪迈。 雪夜风吼、飞沙走石，这些边疆大漠中令人望而生畏的恶劣气候环境，在诗人印象中却成了衬托英雄气概的壮观景色，是一种值得欣赏的奇伟美景。如没有积极进取精神和克服困难的勇气，是很难产生这种感觉的，只有盛唐诗人，才能有此开朗胸襟和此种艺术感受。 主题思想 诗人通过极力渲染恶劣环境，反衬唐军将士在反击侵略、保家卫国的战斗中，不畏艰险、斗志昂扬的英雄气概和爱国精神。 开头极力渲染环境恶劣、风沙遮天蔽日；接着写匈奴借草黄马壮之机入侵，而封将军不畏天寒地冻、严阵以待；最后写敌军闻风丧胆，预祝唐军凯旋。诗虽叙征战，却以叙寒冷为主，暗示冒雪征战之伟功。语句豪爽，如风发泉涌，真实动人。全诗句句用韵，三句一转，节奏急切有力，激越豪壮，别具一格。 英文版]]></content>
      <tags>
        <tag>诗词</tag>
        <tag>课件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD支持测试]]></title>
    <url>%2Fposts%2F9793%2F</url>
    <content type="text"><![CDATA[来源:Cmd Markdown 斜体和粗体使用 *和 ** 表示斜体和粗体。示例：这是 斜体，这是 粗体。 分级标题H1H2H3H4H5H6超链接使用[描述](链接地址)为文字增加外链接。Zure 的链接。 无序列表使用 *，+，- 表示无序列表。示例： 无序列表项 一 无序列表项 二 无序列表项 三 有序列表使用数字和点表示有序列表。示例： 有序列表项 一 有序列表项 二 有序列表项 三 文字引用使用 &gt; 表示文字引用。示例： 野火烧不尽，春风吹又生。 行内代码块使用 `代码表示行内代码块。 示例： 让我们聊聊html`。 代码块使用&lt;!–￼0–&gt; 示例： 1print('hello,world!') 插入图像使用 !\[描述](图片链接地址)插入图像。示例： 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 注脚使用[^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 流程图12345678910st=&gt;start: Start:&gt;baidu.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 序列图示例 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 表格支持 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： 12345678910111213&lt;table&gt; &lt;tr&gt; &lt;th rowspan="2"&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票对应显示如下待办事宜 Todo 列表：​ Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建记录]]></title>
    <url>%2Fposts%2F3baee0e1%2F</url>
    <content type="text"><![CDATA[Hexo+码云 Pages+GitGithub有墙,coding有广告,码云不能绑定域名 Hexo搭建 Hexo官网 部署到码云,我看的那篇找不到了,自己又不想写… Hexo配置参见reuixiy3.2. 站点配置文件注意码云的Pages在子目录下,一定要在站点配置文件修改URL设置语言设置为zh-CN，Next主题的中文语言文件是zh-CN，原来是zh-Hans 部署npm install hexo-deployer-git --save deploy: type: git repo: https://gitee.com/zureov/blog.git branch: master搜索npm install hexo-generator-searchdb --save search: path: search.xml field: post format: html limit: 10000注意使用NexT主题要配置启用 # Local search local_search: enable: true根据目录自动添加分类npm install hexo-auto-category --save # Generate categories from directory-tree # Dependencies: https://github.com/xu-song/hexo-auto-category # depth: the depth of directory-tree you want to generate, should &gt; 0 auto_category: enable: true depth: 3RSS订阅npm install --save hexo-generator-feed plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 0固定链接npm install hexo-abbrlink --save # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://zureov.gitee.io/blog/ root: /blog/ permalink: posts/:abbrlink/ #:year/:month/:day/:title/ permalink_defaults:NexT主题参见reuixiy3.2. 站点配置文件字数统计npm install hexo-symbols-count-time --save #原来NexT用的是hexo-wordcount 相关文章hexo-related-popular-postsValine评论# Valine. # You can get your appid and appkey from https://leancloud.cn # more info please open https://valine.js.org valine: enable: true appid: # your leancloud application appid appkey: # your leancloud application appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go! go! # comment box placeholder avatar: identicon # mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size修改文章底部的带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; NexT自带样式note标签# Note tag (bs-callout). note: style: flat #simple icons: true #false border_radius: 3disabled note tag. light_bg_offset: 0使用 &lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; {% note danger no-icon %} note without icon {% endnote %}所有的FontAwesome图标&lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; 代码块hello,world! www.python123.io python1231print('hello,world!') \`\`\`[language] [title] [url] [link-text] 代码 \`\`\`label 标签{% label default@default %}@ 前面的是label的名字，后面的是要显示的文字 tabs标签自定义样式123&lt;blockquote class="question"&gt;内容&lt;/blockquote&gt;&lt;span id="inline-toc"&gt;1.&lt;/span&gt; 技巧 阅读全文&lt;!-- more --&gt; 可视化写文章插件hexo-admin,感觉并不好 多终端同步我放弃了[摊手]退而求次，同步.md文件]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F16107%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
  </entry>
</search>
